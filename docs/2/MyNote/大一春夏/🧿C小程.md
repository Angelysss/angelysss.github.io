>**一言以概**
>任何看上去有简单答案的问题都藏有坑。


# 数

## 整型常量的规则
* 前缀
	* 十进制首位数字必须是`非0` 
	* 八进制首位数字必须是`0`
	* 十六进制开头必须是`0x`或`0X`
* 后缀：（大小写不敏感）
	* `L` 表示长整型
	* `LL` 表示长长整型
	* `U` 表示无符号整型
	* `U` 和 `L` 可以混使用，不敏感顺序
	* `UL` 表示无符号长整型

## 实数
实数只使用十进制形式表示，不能用八进制或十六进制表示；实数有两种表示方式，即十进制小数形式和指数形式
实数的默认类型为double型，在实数后面加后缀字母f或F表示单精度float型
>十进制形式的实数可以无整数部分或无小数部分，**但不能两者均无**；.123、123.、0.0均合法
>-3.14e5 e前面的数称为尾数，后面的数称为阶码；e可以大写
>>必须得有尾数；在有小数点的情况下，可以无整数部分或小数部分，但不能两者均无；在无小数点的情况下，要同时省略小数部分
>>阶码得是整数，且不能是变量；阶码为1~3位十进制无符号整常数（可以有前置0，如002）
# 字符常量
是用一对单引号括起来的单一字符
单引号中的字符不能是单引号或反斜杠，它们必须用转义字符表示

转义字符的表示：
* 反斜杠`\`后面跟一个字符，用于表示一些常用的控制字符
* 反斜杠`\`后面跟一个字符码，**字符码必须用三位八进制或二位十六进制数表示**，表现形式为'\\ddd'(ddd为三位八进制数)和'\\xdd'(hh为二位十六进制数)；八进制可以省略前缀0，十六进制不能省略x
* 如果不是转义字符，则反斜杠`\`不起作用，也不能进行转义；如'\w'就不是转义字符，系统把它当作'w'看待

字符`\0`是ASCII码值为0的NULL字符，即空操作字符，不是空格字符

| 字符 | ASCLL |
|:----:|:-----:|
|  0   |  48   |
|  A   |  65   |
|  a   |  97   |     

| 数据类型 | 字节数 |
|:--------:|:------:|
|   int    |   2    |
|  float   |   4    |
| double         |    8    |
(int字节数为2仅针对本学期教材)

# 字符串
是用一对双引号括起来的零个或多个字符序列，字符序列中的字符个数称为字符串的长度。字符串常量简称为字符串
* 字符串中的转义字符占一个长度
* 字符串在内存中储存时，系统会自动在字符串的末尾加一个NULL字符（空字符）作为“字符串结束标志”
* 一个字符串可以没有任何字符，表示为""，称之为空串，其长度为0
* 注意：空串""和空格串" "之间的区别。空串中没有字符，而空格串中有空格字符

字符串可以连接;
例如：
```c
printf("Hello，""how are yo?);
```
等价于
```c
printf("Hello,how are you?");
```
但是下面的则是错误的，因为语法规定，**字符串常数必须写成一行**
```c
printf("Hello,
	   how are you?");
```
有两种方法可以将行扩展到下一行：
1. 在末尾加续行符" \ "
2. 依靠字符串的连接功能
```c
printf("Hello,\
how are you?");
```
```c
printf("Hello,"
"how are you?");
```
# 符号常量
在C程序中，允许将程序中多次出现的常量定义为一个标识符，称之为符号常量
定义形式：
```c
#define 符号常量 常量表达式
```
* 习惯上，符号常量名用大写字母，变量用小写字母，以示区别
* 上面的#define 是预编译命令，每一个#define命令只能定义一个符号常量，且一个符号常量定义必须占一行，不用分号结尾

# 变量
* 变量名无长度限制，但是C编译系统对变量名是有有效长度的，超过有效长度部分无效，只认有效长度内的变量。建议命名变量时长度不超过8个字符
* **变量名必须以英文字母或下划线开头，且变量名字符序列中只能出现字母、数字和下划线**
* 注意：大写字母和小写字母被认为是两个不同的字符，习惯上变量名使用小写字母；因此A 和a是两个不同的变量
* 注意：变量名不能和C语言的本身使用的关键字重名

# 运算符
## BASIC
`/`运算符可用于整数除和实数除
>**当两个操作数都是整数，则执行整数除，运算结果取其商的整数部分**；否则，执行实数除，运算结果为实数

`%`求余运算符
>**规定两操作数必须是整数**
>运算结果与被除数（即左边的操作数）的符号一致

`++` `--`自增、自减运算符的操作数只能是变量，不能是常量或表达式（结合方向为R）
>注意：取负数运算符`-`和减运算符是一样的，但是取负数运算符的结合性为R。因此`-i++`应理解为`-(i++)`

如果 i 的值为4，则
```c
printf("%d",-i++);
```
输出结果为 -4

`=`赋值运算符
>当赋值运算符两边的数据类型不同时，由系统自动进行类型转换，其原则是**赋值运算符右边的数据类型转换成左边的类型**

## 运算符的优先级
>**逻辑非！> 逻辑与&&> 逻辑或||**
```c
if (!a && b)
```
先对a取反，再和b进行逻辑与的运算

## 算术运算符的优先次序
>高 (++ -- -) (* / %) (+ -) 低
>括号内的运算符优先级相同


## 0<x<5无意义
这样的写法并没有错误，但是无意义
因为<的运算顺序是从左到右的，所以0<x<5被理解为 **(0<x)<5**
>正确的写法是使用逻辑运算符&&，表示两个条件都必须满足，才能返回真值
# 常用的数学函数
* `sqrt(x)` $\sqrt{x}$ 
* `pow(x,n)` $x^n$ 
* `exp(x)` $e^x$ 
* `fabs(x)` $\left | x \right |$ 
* `log(x)` $\ln_{}{x}$ 
均返回double类型

# 数组

## 字符数组
使用双引号括起来表示一个字符串常量，而单引号只能用于表示单个字符

* 部分初始化：`char arr[5]={'1','2','\0'}` 指定部分初值，未被初始化的元素自动赋值为`0`；需要在里面添加`\0` ,否则会有异常情况（也可以逐个元素初始化）
* 完全初始化：用字符串来初始化整个字符数组 `char arr[ ]={"12"};` ，不用手动加`\0` ，会自动添加；{}可加可不加

### 输入
使用scanf()函数来读取读取字符串时，不用在数组名前加`&` ，因为数组名已经表示了数组的地址。而对于其他类型的变量，我们需要在变量名前加上`&`符号来获取其地址
```c
char arr[10];
scanf("%s", str);

```
还可以用fgets()函数输入字符串

### 输出

```c
char str[] = "Hello, world!";
printf("%s\n", str);

```
或
```c
char str[] = "Hello, world!";
puts(str);

```
puts()函数会自动在字符串末尾添加一个换行符，并且不支持格式说明符

错误示范：
```c
printf("%s\n",a[ ]);
```
在使用printf()函数输出字符数组时，应该将数组名作为参数传递给函数，而不是用下标访问数组的每个元素

## 二维数组
不需要像字符串那样以`\0`结尾
* **在初始化时，可以省略第一维，但不能省略第二维；但是在定义时，一个都不能省略！**
* **初始化时必须按行进行！**

定义三阶矩阵格式：


按行初始化：
```c
int matrix[3][3] = 
{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

```
按元素初始化每一行就不要那些个{}

三阶零矩阵：
```c
int matrix[3][3] = {{0}};

```


# 函数
## strlen()
一个字符串函数，用于计算字符串的长度，即字符串中字符的个数，**不包括字符串末尾的空字符`\0`**；使用strlen()函数需要包含头文件<string.h>
```c
size = strlen(str);

```

## switch()
有以下几个规则：
- switch后面的表达式必须是一个整型，或者是一个有单一转换函数的类类型。
- **case后面的常量表达式必须与switch中的变量具有相同的数据类型，且必须是一个常量，不可以是变量的参与的表达式**
- 当表达式的值与某个case后面的值相等时，就执行该case后面的语句，直到遇到break或者switch块结束为止。
- **如果没有任何case匹配，则执行default后面的语句，如果没有default，则不执行任何语句。**
>==break语句的作用是跳出循环或者switch语句。==
>当break语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
>当break语句出现在一个switch语句中时，它会终止switch语句的执行，并跳到switch语句后面的代码。

`case`后面要打空格，不打空格可能过编译但是无法正常判断
* `case 'a'` 有效
* `case'a'` 有效
* `casea` 无效
* `case1` 无效

## break continue
* break语句用于立即退出当前循环，不再执行循环体内余下的语句，而直接跳转到循环体之后的语句执行。break语句通常和if条件语句一起使用，当某个条件满足时，立即退出当前循环
* continue语句用于跳过当前循环中余下的语句，直接进入下一次循环。continue语句通常和if条件语句一起使用，当某个条件满足时，跳过当前循环的余下语句，直接进入下一次循环

## if 判断语句对变
if的判断语句对变量进行运算会改变变量的值；赋值语句本身也是一个表达式，也是有返回值的，它的返回值就是赋值给变量的值

```c
if (a++)
```
先判断a是否为真，再对a进行自增运算。==**但是，无论是真是假，a的值都会加1

## strcpy()
字符串复制函数
```c
strcpy(字符数组名，字符串)
```

拷贝时，`\0`一起被拷贝，故“字符数组”的长度大于等于“字符串”中字符串长度+1
## strcat()
字符串连接函数
```c
strcat(字符数组名，字符串)
```
取消“字符数组”的结束标志`\0`，然后把“字符串”连接到“字符数组”的后面，并在最后加上`\0` 

## sizeof()
计算某数据类型或变量在内存中所占字节数
# 儿童节😅

```c
if(a=2)
```
一个 `=` 是赋值符号，**两个 `=` 才是等于号**

本课本的 `double` 的格式符，输入是 `%lf` ，输出是 `%f` 
(其实都应该是%lf)

整型常量有十、八、十六进制哦

```c
int x=3;y=3;
if (!x && y++)
```
执行后 y 的值仍然为3！！！
因为 !x 为假，而**逻辑与第一个表达式为假，所以不再进行第二个表达式计算**

strcmp函数 从左到右逐个比较两个字符串中对应位置的字符的ASCII码值。如果两个字符串在某个位置上的字符不同，则比较它们的ASCII码值，如果相同则继续比较下一个字符，直到找到不同的字符或者比较完整个字符串。

EOF的值为-1，通常用于表示文件读取或写入操作已经到达了文件的末尾。EOF常量通常用于与文件输入输出函数一起使用